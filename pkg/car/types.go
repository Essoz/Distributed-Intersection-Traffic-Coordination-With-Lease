// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package car

import "fmt"
import "encoding/json"

type CarMetadata struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CarMetadata) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in CarMetadata: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in CarMetadata: required")
	}
	type Plain CarMetadata
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CarMetadata(plain)
	return nil
}

type CarSpecPassingBlocksElem struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name"`

	// Position corresponds to the JSON schema field "position".
	Position []float64 `json:"position" yaml:"position"`

	// Size corresponds to the JSON schema field "size".
	Size []float64 `json:"size" yaml:"size"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CarSpecPassingBlocksElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in CarSpecPassingBlocksElem: required")
	}
	if v, ok := raw["position"]; !ok || v == nil {
		return fmt.Errorf("field position in CarSpecPassingBlocksElem: required")
	}
	if v, ok := raw["size"]; !ok || v == nil {
		return fmt.Errorf("field size in CarSpecPassingBlocksElem: required")
	}
	type Plain CarSpecPassingBlocksElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CarSpecPassingBlocksElem(plain)
	return nil
}

// These are dynamic properties that are updated by the simulator
type CarSpec struct {
	// Acceleration corresponds to the JSON schema field "acceleration".
	Acceleration float64 `json:"acceleration" yaml:"acceleration"`

	// Destination corresponds to the JSON schema field "destination".
	Destination []float64 `json:"destination" yaml:"destination"`

	// Heading corresponds to the JSON schema field "heading".
	Heading float64 `json:"heading" yaml:"heading"`

	// Location corresponds to the JSON schema field "location".
	Location []float64 `json:"location" yaml:"location"`

	// PassingBlocks corresponds to the JSON schema field "passingBlocks".
	PassingBlocks []CarSpecPassingBlocksElem `json:"passingBlocks" yaml:"passingBlocks"`

	// Speed corresponds to the JSON schema field "speed".
	Speed float64 `json:"speed" yaml:"speed"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CarSpec) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["acceleration"]; !ok || v == nil {
		return fmt.Errorf("field acceleration in CarSpec: required")
	}
	if v, ok := raw["destination"]; !ok || v == nil {
		return fmt.Errorf("field destination in CarSpec: required")
	}
	if v, ok := raw["heading"]; !ok || v == nil {
		return fmt.Errorf("field heading in CarSpec: required")
	}
	if v, ok := raw["location"]; !ok || v == nil {
		return fmt.Errorf("field location in CarSpec: required")
	}
	if v, ok := raw["passingBlocks"]; !ok || v == nil {
		return fmt.Errorf("field passingBlocks in CarSpec: required")
	}
	if v, ok := raw["speed"]; !ok || v == nil {
		return fmt.Errorf("field speed in CarSpec: required")
	}
	type Plain CarSpec
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CarSpec(plain)
	return nil
}

type Car struct {
	// Metadata corresponds to the JSON schema field "metadata".
	Metadata CarMetadata `json:"metadata" yaml:"metadata"`

	// These are dynamic properties that are updated by the simulator
	Spec *CarSpec `json:"spec,omitempty" yaml:"spec,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Car) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["metadata"]; !ok || v == nil {
		return fmt.Errorf("field metadata in Car: required")
	}
	type Plain Car
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Car(plain)
	return nil
}
