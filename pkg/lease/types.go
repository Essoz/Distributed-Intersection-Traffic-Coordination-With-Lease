package lease

import (
	"encoding/json"
	"fmt"
)

type Lease struct {
	CarId     int
	BlockId   int
	StartTime int
	EndTime   int
}

type Block struct {
	Id     int
	Leases []Lease
}

// Below are code pieces generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

type IntersectionMetadata struct {
	// name of the intersection, this name can be used to retrieve the intersection
	// from the database
	Name string `json:"name" yaml:"name"`
}

type IntersectionSpecBlocksElem struct {
	// name of the block, this name can be used to retrieve the block from the
	// database
	Name string `json:"name" yaml:"name"`

	// position of the block in centimeters
	Position []float64 `json:"position" yaml:"position"`

	// size of the block in centimeters
	Size []float64 `json:"size" yaml:"size"`
}

type IntersectionSpec struct {
	// Blocks corresponds to the JSON schema field "blocks".
	Blocks []IntersectionSpecBlocksElem `json:"blocks" yaml:"blocks"`

	// position of the intersection in centimeters
	Position []float64 `json:"position" yaml:"position"`

	// size of the intersection in centimeters
	Size []float64 `json:"size" yaml:"size"`

	// the intersection will be equally split into 2^splitIndex blocks
	SplitIndex float64 `json:"splitIndex" yaml:"splitIndex"`
}

type Intersection struct {
	// Metadata corresponds to the JSON schema field "metadata".
	Metadata IntersectionMetadata `json:"metadata" yaml:"metadata"`

	// Spec corresponds to the JSON schema field "spec".
	Spec IntersectionSpec `json:"spec" yaml:"spec"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IntersectionMetadata) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in IntersectionMetadata: required")
	}
	type Plain IntersectionMetadata
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = IntersectionMetadata(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IntersectionSpecBlocksElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in IntersectionSpecBlocksElem: required")
	}
	if v, ok := raw["position"]; !ok || v == nil {
		return fmt.Errorf("field position in IntersectionSpecBlocksElem: required")
	}
	if v, ok := raw["size"]; !ok || v == nil {
		return fmt.Errorf("field size in IntersectionSpecBlocksElem: required")
	}
	type Plain IntersectionSpecBlocksElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Position) < 2 {
		return fmt.Errorf("field %s length: must be >= %d", "position", 2)
	}
	if len(plain.Position) > 2 {
		return fmt.Errorf("field %s length: must be <= %d", "position", 2)
	}
	if len(plain.Size) < 2 {
		return fmt.Errorf("field %s length: must be >= %d", "size", 2)
	}
	if len(plain.Size) > 2 {
		return fmt.Errorf("field %s length: must be <= %d", "size", 2)
	}
	*j = IntersectionSpecBlocksElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IntersectionSpec) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["blocks"]; !ok || v == nil {
		return fmt.Errorf("field blocks in IntersectionSpec: required")
	}
	if v, ok := raw["position"]; !ok || v == nil {
		return fmt.Errorf("field position in IntersectionSpec: required")
	}
	if v, ok := raw["size"]; !ok || v == nil {
		return fmt.Errorf("field size in IntersectionSpec: required")
	}
	if v, ok := raw["splitIndex"]; !ok || v == nil {
		return fmt.Errorf("field splitIndex in IntersectionSpec: required")
	}
	type Plain IntersectionSpec
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Position) < 2 {
		return fmt.Errorf("field %s length: must be >= %d", "position", 2)
	}
	if len(plain.Position) > 2 {
		return fmt.Errorf("field %s length: must be <= %d", "position", 2)
	}
	if len(plain.Size) < 2 {
		return fmt.Errorf("field %s length: must be >= %d", "size", 2)
	}
	if len(plain.Size) > 2 {
		return fmt.Errorf("field %s length: must be <= %d", "size", 2)
	}
	*j = IntersectionSpec(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Intersection) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["metadata"]; !ok || v == nil {
		return fmt.Errorf("field metadata in Intersection: required")
	}
	if v, ok := raw["spec"]; !ok || v == nil {
		return fmt.Errorf("field spec in Intersection: required")
	}
	type Plain Intersection
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Intersection(plain)
	return nil
}
